//
//  拷贝深拷贝.h
//  MyBaseProgect
//
//  Created by 张威威 on 2018/5/8.
//  Copyright © 2018年 张威威. All rights reserved.
//
 /*
  
  copy与retain的区别：
  copy是创建一个新对象，retain是创建一个指针，引用对象计数加1。Copy属性表示两个对象内容相同，新的对象retain为1 ，与旧有对象的引用计数无关，旧有对象没有变化。copy减少对象对上下文的依赖。
  
  retain属性表示两个对象地址相同（建立一个指针，指针拷贝），内容当然相同，这个对象的retain值+1也就是说，retain 是指针拷贝，copy 是内容拷贝。
  
  当然在ios中并不是所有的对象都支持copy，mutableCopy，遵守NSCopying 协议的类可以发送copy消息，遵守NSMutableCopying 协议的类才可以发送mutableCopy消息。假如发送了一个没有遵守上诉两协议而发送 copy或者 mutableCopy,那么就会发生异常。但是默认的ios类并没有遵守这两个协议。如果想自定义一下copy 那么就必须遵守NSCopying,并且实现 copyWithZone: 方法，如果想自定义一下mutableCopy 那么就必须遵守NSMutableCopying,并且实现 mutableCopyWithZone: 方法。
  
  在OC里面有个值对象的概念，当你新定义一个属性是值对象时就应该用copy来修饰。那么都什么对象是值对象呢？
  值对象: 指封装了基本值（属于 C 数据类型）且提供与该值相关的服务的对象。值对象以对象形式表示标量类型。Foundation 框架向您提供了以下类（这些类产生对象，用于字符串、二进制数据、日期与时间、数字以及其他值）：
  
  NSString和NSMutableString ,  NSData和NSMutableData  ,  NSDate  ,   NSNumber   ,  NSValue
  
  B:
  当一个指针执行的对象属性值发生改变时，不影响另一个对象，那么需要分配两个不同的内存地址，也就是说，我们就不可以采用retain关键字了，而是要采用copy 关键字，因为copy关键字会在复制时重新创建一个新的对象。
  这里再提一下 : Copy:建立一个索引计数为1的对象，在赋值时使用传入值的一份拷贝。
  (扩展:深拷贝[内存]和浅拷贝[指针]最大区别是什么?:“主要看子类对象的地址是否一致”)
  
  
  深拷贝和浅拷贝的理解？
  
  总结：深拷贝拷贝的是内容，浅拷贝拷贝的是指针。深拷贝和浅拷贝最大的区别就是子类对象的地址是否改变，如果子类对象的地址改变那么就是深拷贝。
  
  详细解释：
  
  浅层复制(copy):只复制指向对象的指针,而不复制引用对象本身。通过对象的指针来访问这个对象----只赋值地址
  
  深层复制(mutableCopy):复制引用对象本身---再创建一个对象
  
  意思就是有个A对象,复制一份后得到A_copy对象后,对于浅复制来说,A和A_copy指向的是同一个内存资源,复制的只不过是是一个指针,对象本身资源还是只有一份,那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改,这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了两份独立对象本身。//当修改A时,A copy不变。
  
  
  https://blog.csdn.net/u010664555/article/details/41786815
  
  
  
  
  
  
  
  
  
  
  
  
  */
